#!/bin/bash
##
## _______
## bashism
##
## -- A hackerwork for writing reusable bash scripts; An attempt to seperate function and form to script with ease.
##
## ~trevorj <[github@skywww.net]>
##
set -eE
shopt -s nullglob
shopt -s extglob
declare -A __BASHISM=([path]="${BASH_SOURCE[0]%/*}" [cmd_path]="bashism bashism.var")

## Look for relevant cmdline args
while getopts "dqtc" opt; do case "$opt" in
	## Turn on extended debugging if we're debugging
	d)	__BASHISM[debug]=0; shopt -s extdebug ;;
	q)	__BASHISM[quiet]=0; ;;
	## Start tracing if requested
	t)	__BASHISM[trace]=0; set -xv ;;
	c)	__BASHISM[colors]=0; ;;
esac; done; shift $((OPTIND-1)); OPTIND=1

## -> b.cmd($cmd, @args)
function bashism.cmd() {
	local cmd="${1#.}"

	case "cmd" in
		b.*)		cmd="bashism.${cmd#b.}" ;;
		#this.*)	cmd="${__BASHISM[package]}.${cmd#this.}" ;;&
	esac

	local i=; for i in '' ${__BASHISM[cmd_path]}; do
		[[ -z "$i" ]] || i="$i."
		declare -f -F "$i$cmd" >/dev/null || continue
		"$i$cmd" "${@:2}"; return $?
	done

	for i in "${cmd#*.}"; do
		i="${__BASHISM[$i]}"
		[[ -n "$i" ]] || continue
		echo "$i"; return 0
	done

	return 127
}

b="bashism.cmd "; this="$b this"

## -> b.include(@args)
function bashism.include() {
	local i=; for i in "$@"; do
		i="${__BASHISM[path]}/bashism.d/${i}.sh"
		[[ -f "$i" ]] && . "$i" || exit 1
	done
}

## Trap errors to cleanup afterwards
function bashism.on_error() {
	trap - INT TERM EXIT
	bashism.hooks.run on_error cleanup
	exit 1
}
trap bashism.on_error INT TERM EXIT

## Disable trap then exit
function bashism.exit() {
	trap - INT TERM EXIT
	exit $1
}

## Core
$b.include util var output colors hooks

## Run init
$b.hooks.run init

